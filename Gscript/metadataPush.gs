/**
 * @OnlyCurrentDoc
 */
const OWNER = 'EVORA-project';
const REPO = 'evora-ontology';
const STAGING_BRANCH = 'staging';
const PROD_BRANCH = 'main';
const MODELS_WORKFLOW_ID = 'generate_schema_models.yml';
const MERGE_WORKFLOW_ID = 'merge.yml';
const LOG_SHEET_NAME = 'Log';

const GITHUB_API_URL = 'https://api.github.com';
const GITHUB_CONTENT_TYPE = 'application/vnd.github+json';
const GITHUB_RAW_CONTENT_TYPE = 'application/vnd.github.v3.raw';

/**
 * Adds custom menu items to the Google Sheet UI.
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('|Sync_@_GitHub|')
    .addItem('STAGING: Sync Metadata GSheet with staging branch', 'generateModelsOnStagingBranch')
    .addItem('PROD/MAIN: Merge staging into production branch', 'mergeStagingIntoMainBranch')
    .addToUi();
}

/**
 * Triggers the workflow to generate models on the staging branch.
 */
function generateModelsOnStagingBranch() {
  const ui = SpreadsheetApp.getUi();
  try {
    let version = getSpreadsheetVersion();

    if (!isBranchSynced(STAGING_BRANCH, version) && !isBranchSynced(PROD_BRANCH, version-1)) {
      // we anticipate the version number evolution by the log addition: version++
      version++;

      const commitMessage = getCommitMessage(version, ui);
      if (!commitMessage) return;

      // We log the message before triggering the workflow as a new version number is generated by the change
      logCommitMessage('Staging', version, commitMessage);
      
      // get the new official version number after log message
      version = getSpreadsheetVersion();

      triggerWorkflow(MODELS_WORKFLOW_ID, STAGING_BRANCH, {
        version,
        commitMessage: commitMessage
      });

      ui.alert(`Successfully triggered workflow on staging branch with metadata version ${version}, check build results on staging branch before merging in PROD/main.`);
    }
     else if(isBranchSynced(PROD_BRANCH, version - 1)){
      const message = `Staging branch is already synced with metadata version ${version-1} and was merged into PROD/Main branch. New modification required before triggering sync workflow`;
      ui.alert(message);
    }
    else {
      const message = `Staging branch is already synced with metadata version ${version}.`;
      ui.alert(message);
    }
  } catch (error) {
    handleError(error, 'Error triggering workflow on staging branch.');
  }
}

/**
 * Merges the staging branch into the production branch.
 */
function mergeStagingIntoMainBranch() {
  const ui = SpreadsheetApp.getUi();
  try {
    const version = getSpreadsheetVersion();
    // Check if current metadata minus merging log was merged into main (version-1) 
    if (isBranchSynced(PROD_BRANCH, version - 1)) {
      ui.alert(`Production branch is already synced with metadata version ${version-1}.`);
      return;
    }

    if (!isBranchSynced(STAGING_BRANCH, version)) {
      ui.alert('Staging branch is not synced. Sync required before merging.');
      return;
    }

    triggerWorkflow(MERGE_WORKFLOW_ID, STAGING_BRANCH, { version });

    logCommitMessage(PROD_BRANCH, version, 'Auto-generated merge commit');

    ui.alert(`Successfully triggered merge workflow on production branch with metadata version ${version}.`);
  } catch (error) {
    handleError(error, 'Error merging staging into production branch.');
  }
}

/**
 * Checks if the branch is synced with the given metadata version.
 */
function isBranchSynced(branch, version) {
  try {
    const url = `${GITHUB_API_URL}/repos/${OWNER}/${REPO}/contents/metadata_version?ref=${branch}`;
    const options = createApiOptions('get', null, GITHUB_RAW_CONTENT_TYPE);
    const metadataVersion = UrlFetchApp.fetch(url, options).getContentText().replace(/[^0-9]/g, '');
    return metadataVersion === version.toString();
  } catch (error) {
    handleError(error, `Error checking sync status for branch: ${branch}`);
    return false;
  }
}

/**
 * Retrieves the current version of the spreadsheet.
 */
function getSpreadsheetVersion() {
  const currentSpreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const fileId = currentSpreadsheet.getId();
  const revisions = Drive.Revisions.list(fileId).revisions;
  const latestRevision = revisions[revisions.length - 1];
  return latestRevision.id;
}

/**
 * Retrieves the GitHub token from script properties.
 */
function getGithubToken() {
  const token = PropertiesService.getScriptProperties().getProperty('GITHUB_EVORA_TOKEN');
  if (!token) {
    throw new Error('GitHub token is not set in script properties.');
  }
  return token;
}

/**
 * Creates API options for making requests to GitHub.
 */
function createApiOptions(method, payload, accept = GITHUB_CONTENT_TYPE) {
  return {
    method: method,
    contentType: 'application/json',
    headers: {
      Accept: accept,
      Authorization: `Bearer ${getGithubToken()}`,
    },
    payload: payload ? JSON.stringify(payload) : null,
  };
}

/**
 * Triggers a GitHub Actions workflow.
 */
function triggerWorkflow(workflowId, branch, inputs) {
  const url = `${GITHUB_API_URL}/repos/${OWNER}/${REPO}/actions/workflows/${workflowId}/dispatches`;
  const options = createApiOptions('post', { ref: branch, inputs });
  UrlFetchApp.fetch(url, options);
  Logger.log(`Triggered workflow: ${workflowId} on branch: ${branch}`);
}

/**
 * Logs commit messages to the Google Sheet.
 */
function logCommitMessage(branch, version, commitMessage) {
  let logSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(LOG_SHEET_NAME);
  if (!logSheet) {
    logSheet = SpreadsheetApp.getActiveSpreadsheet().insertSheet(LOG_SHEET_NAME);
  }
  logSheet.appendRow([new Date(), branch, version, commitMessage]);
}

/**
 * Prompts the user for a commit message.
 */
function getCommitMessage(version, ui) {
  const commitMessage = ui.prompt(
    'Short description of last modifications',
    `Your commit message for metadata version ${version}:`,
    ui.ButtonSet.OK_CANCEL
  );

  if (commitMessage.getSelectedButton() === ui.Button.CANCEL) {
    ui.alert('Sync process CANCELED!');
    return null;
  }
  else if (commitMessage.getSelectedButton() === ui.Button.OK &&  commitMessage.getResponseText().trim() === '') {
    ui.alert('Sync process CANCELED as no commit message was provided.');
    return null;
  }

  return commitMessage.getResponseText().trim();
}

/**
 * Handles and logs errors.
 */
function handleError(error, message) {
  Logger.log(`${message}\n${error.message}`);
  SpreadsheetApp.getUi().alert(`${message}\nSee logs for more details.`);
}
